[
  {
    "objectID": "pages/999-contributors.html",
    "href": "pages/999-contributors.html",
    "title": "Contributors",
    "section": "",
    "text": "This course was originally written by Christopher Woods and published at https://chryswoods.com/beginning_git.\nThe course has since been modified by the Jean Golding Institute and adapted for the UKRN.",
    "crumbs": [
      "Contributors"
    ]
  },
  {
    "objectID": "pages/100-installing.html",
    "href": "pages/100-installing.html",
    "title": "Installing Git",
    "section": "",
    "text": "Git is open source, free, and is available for easy installation on a range of operating systems, including Windows, macOS and Linux.\nYou will need to have installed the command line version control tool “git”. The instructions below tell you how to install it on each of these platforms.\n\n\n\n\n\n\nCommand Line Interface\n\n\n\nIf you don’t have experience working with a Command Line Interface, you can check the training course Introduction to the Command Line Interface.\n\n\n\nWindows\nYou can install git by downloading an installer from https://git-scm.com/download/win.\nOnce you have downloaded the installer, double click on the downloaded file to execute it. Follow the instructions of the installer (click “Next” to accept the license etc.). Make sure that everything associated with Git Bash is enabled, and “Use Git from Git Bash only” is selected.\nAlternatively, if you are using Anaconda, you can install git from the command line:\nconda install -c anaconda git\n\n\nmacOS\nOn macOS, you have several choices for how you install git.\n\nYou can use the git that is installed as part of Xcode (Apple’s free development environment that is supplied as a separate download for macOS).\nInstall git by going to the official git website and choose macOS.\n\n\n\nLinux\nPlease install Git using your package manager, e.g. following the instructions here. The exact command you type will depend on your Linux distribution. Typically, the command will look like apt-get install git, or yum install git, or dnf install git.\n\n\nStarting Git\nOnce you have installed git, you now need to start a command window. On Windows, you do this by starting Git Bash. On Linux or macOS you need to open a command window (e.g. also called a “terminal”, “bash window”, “console”).\nTo check that git is working, please type the following in the command window and press return;\ngit --version\nThis should run the git command, and will print the version number of git to the screen. For example, on my Mac, I see this printed;\ngit version 2.24.3 (Apple Git-128)\nIf you see something like this printed;\ncommand not found: git\nthen that means that git is not installed, or something is wrong. Please go through the installation instructions again and double-check you have followed all steps.\n\n\nChoosing a text editor\nWe will also need to use a text editor. A text editor is a program that lets you create and edit simple text files. There are many different text editors available. You are free to choose the one you like the best. Commonly-installed text editors include;\n\nnano - this is a good text editor for beginners (and my favorite and personal choice). It should be installed by default on macOS and Git Bash on Windows.\nvim - this is a standard text editor that is installed nearly everywhere, and is definitely available on all platforms. This is a more complex text editor to use, and is not recommended for beginners.\nnotepad++ - this is a graphic text editor for Windows. This is very easy for beginners to use, but is not available for macOS or Linux.\n\n\n\nConfiguring Git\nThe first thing you have to do when using Git for the first time on a computer is to tell Git who you are. This will allow Git to keep a record of who owns or changes the files that it will manage.\nTell Git your name using the command\ngit config --global user.name \"Your Full Name\"\nwhere \"Your Full Name\" is your full name, e.g. for me I would type\ngit config --global user.name \"Jean Golding\"\nNext you need to give Git your email address. Do this using the command\ngit config --global user.email \"Your Email Address\"\nwhere \"Your Email Address\" is your email address, e.g. for me I would type\ngit config --global user.email \"ab01234@bristol.ac.uk\"\nFinally, you should tell Git which text editor you want to use when it asks you to enter extra information. This should be the text editor that you installed in the last section. You do this using the command\ngit config --global core.editor \"Your text editor\"\nI prefer to use nano, so for me I would type\ngit config --global core.editor \"nano\"\n(note, on Windows if you want to use notepad++ that you will need to type in the full path to the executable, e.g. git config --global core.editor \"C:\\Program Files (x86)\\Notepad++\\notepad++.exe\")\nYou only need to type the above commands once, the first time that you use git on a new computer. These options are saved and are then used every time you use git. You can change these at any time just by running the commands again. You can also see the current value of these variables by typing the command without the value, e.g.\ngit config --global user.name\nwill print\nJean Golding\nNote also that this information is stored privately on your computer. Your email address and name won’t be shared publicly yet. This information will only be shared if you back up to a cloud service, such as GitHub (see later in this workshop). You don’t need to use real information, and can use a dummy email address or name alias if you want.",
    "crumbs": [
      "Installing Git"
    ]
  },
  {
    "objectID": "pages/400-adding.html",
    "href": "pages/400-adding.html",
    "title": "Adding files",
    "section": "",
    "text": "Git is designed to version control files that are within a directory. To start, we first need to create a file in our versioned_dir directory that Git can version control.\nCreate a new text file called README.md using your text editor. For example, if you are using nano, you can do this by typing;\nnano README.md\nInto this file copy in the below text;\n# Hello World\n\nThis is a text file that we are going to add to Git.\n\nWe will use Git to record all of the versions of this file,\nletting us move back and forth through time.\n\nFor example, in this first version of the file we\nwill say that the cat goes woof.\nNow save the file and close the text editor. In nano, you do this by pressing the control key (Ctrl) and the “x” key at the same time. Confirm you want to save by pressing the “y” key, then press return to confirm that you want to save the file with the name README.md.\n(if you are using vim, you can exit by pressing the escape key, then type :x, then press return)\nOnce you have exited the text editor you should be able to type commands in the command window. Let’s check that our README.md file has been created by using the ls command. Type;\nls\nand press return. You should see that README.md is now printed to the screen, showing that this file is contained in the current directory.\n\nGetting the status of the directory\nGit will monitors the status of files within the version controlled directory. You can ask git to print the current status using this command;\ngit status\nIf you type this command and press return you should see something similar to this printed;\nOn branch master\n\nNo commits yet\n\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n    README.md\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nThis output is git’s way of telling us that it has seen that a new file has been added to the directory. By default, git will not track the versions of new files. This is why our README.md is listed as an Untracked file.\nGit will only save versions of files that it tracks. Hence we now need to ask git to track this file. Git helpfully tells us in the output that we can do this using the git add command. To track README.md, we just need to type;\ngit add README.md\nand press return.\nIf you now get the status again…\ngit status\nyou should now see something similar to this printed;\nOn branch master\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached &lt;file&gt;...\" to unstage)\n    new file:   README.md\nThis output shows that git now recognises that README.md is a new file whose version it should now monitor.",
    "crumbs": [
      "Adding files"
    ]
  },
  {
    "objectID": "pages/900-github.html",
    "href": "pages/900-github.html",
    "title": "Using GitHub",
    "section": "",
    "text": "A question you may have, is where is the repository stored? Where are all of the versions of the directory that you have saved?\nThe can be found by typing;\nls -a\nThis will list all files, including hidden files in the directory.\nYou should see something that looks like this;\n.git          README.md     background.md notes.md\nNotice that there is an extra hidden file called .git in your directory. This is actually a hidden directory, which you can explore via\nls .git\nOn my computer, the .git directory contains\nCOMMIT_EDITMSG config         hooks          info           objects\nHEAD           description    index          logs           refs\nThe .git directory is where git saves the entire repository, and thus all versions of all files that have been committed.\nYOU MUST NOT EDIT OR CHANGE THE .git DIRECTORY IN ANY WAY, this will break git, and potentially lose all of the old versions of files that were committed to the repository.\nBecause the .git folder is saved in versioned_dir, this means that if you accidentally delete versioned_dir, then you will also have deleted the entire git repository. You will thus not be able to recover or restore the files. Equally, if your computer is lost or breaks.\n\n\n\n\n\n\nBacking up your data\n\n\n\nGit is NOT a backup tool. It only version controls your files, it DOES NOT back them up.\n\n\n\nGit hosting services\nAn alternative to backing up manually (USB drive, Dropbox,…) is to use a git backup service. These are online services that store a backup of your .git folder. There are special commands in git that then integrate with these services, and which make backing up and restoring very easy and straightforward. Additionally, Git hosting services enable researchers to share their work publicly, making it accessible for others to review and reproduce.\nThe three most established git hosting services are GitHub, GitLab and BitBucket. Of the three, GitHub is the one most people know.\nGitHub is free for public repositories (those that can be viewed by anyone, anywhere), and you can have a small number of private projects (those that only you have access to).\n\n\nInstalling a Git Credential Helper\nBefore you use GitHub, you need to install a “Git credential manager”. This is a program that will let your git command-line client manage the login credentials needed to connect to your GitHub account.\nYou can install a “Git credential manager” by following the instructions here. This credential manager is available for Linux, MacOS and Windows. Note that the “Git credential manager” is included with Git for Windows and would have been installed by default as long as you left “Git Credential Manager Core” selected.\n\n\nCreating a GitHub repository\nTo use GitHub, register to create an account, and the log in. Once you have logged in, click the “New Repository” button to create a new repository (this button is in the menu of the “+” button at the top right of the page).\nThis will bring you to the page to create a new repository. The page will look something like this (possibly different colours or layout);\n\nChoose a name for your repository. I’ve used versioned_dir, as this is what I called the directory on my computer. You can use any name you want, and it does not need to match the name on your computer.\nI’ve left the repository type to “Public” (meaning everything is published openly), and am not initialising the repository with anything (as we will be uploading our existing versioned_dir in the next step).\nClick “Create Repository” to create the new repository. It will start off being empty, and something like this page should be seen.\n\nThis page gives instructions for the three different ways that you can add files to this repository. In this case, we will use the “push an existing repository from the command line” option. The commands to do this are written on the page, so we will copy and paste\ngit remote add origin https://github.com/ab01234/versioned_dir.git\ngit push -u origin main\nAlternatively, we could run\ngit clone https://github.com/ab01234/versioned_dir\nIf this is the first time you have used GitHub, then it is likely that you will be asked to log in when you ran the git push command. The method you use to log in will depend on your account and operating system. In most cases, the easiest is to use the option to log in via your web browser. This will open a tab in your browser and will ask you to log in there with your GitHub username and password (and possibly multi-factor authenticator too).\nAssuming you could log in correctly, then you should see output that looks something like this;\nEnumerating objects: 21, done.\nCounting objects: 100% (21/21), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (16/16), done.\nWriting objects: 100% (21/21), 2.23 KiB | 2.23 MiB/s, done.\nTotal 21 (delta 5), reused 0 (delta 0)\nremote: Resolving deltas: 100% (5/5), done.\nTo https://github.com/ab01234/versioned_dir.git\n * [new branch]      main -&gt; main\nBranch 'main' set up to track remote branch 'main' from 'origin'.\nThis shows that our local versions in our .git folder have been pushed up to the .git folder on GitHub (in my case https://github.com/ab01234/versioned_dir.git). Git has also been set up so that the local main on our computer is set to track the remote main on GitHub.\nIf you refresh the GitHub page you should now see that your files have been uploaded, e.g.\n\nYou can use the GitHub interface to explore the files in your repository. For example, you can navigate to any version in the repository by clicking the “Commits” (the “9 commits” on the right). This will show all of the versions that have been saved, together with the log messages. Cool :-)\n\n\n\nBacking up new changes\nYou have now backed up the .git directory of versioned_dir to GitHub. But what if we make new changes and save new versions?\nLet’s change README.md, e.g. by changing the last line to read;\nwill say that the cat goes meow and kittens are cute.\nCommit this change to the repository using\ngit commit -a\nNow run git status. You should see output that looks something like this;\nOn branch main\nYour branch is ahead of 'origin/main' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nnothing to commit, working tree clean\nThis shows that git knows that your working tree is clean, but that the main in your local repository now has one commit more than the main on GitHub. It is ahead of GitHub by 1 commit. We can send this new commit to GitHub using the command git push. Type this now;\ngit push\nYou should see output that looks something like this;\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 396 bytes | 396.00 KiB/s, done.\nTotal 3 (delta 1), reused 0 (delta 0)\nremote: Resolving deltas: 100% (1/1), completed with 1 local object.\nTo https://github.com/ab01234/versioned_dir.git\n   20be956..38db1ae  main -&gt; main\nThis shows that the new commit has been pushed (uploaded) from your local main in your local .git folder and copied to the main in the .git folder on GitHub.\nIf you type git status again, you should see output like this;\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nnothing to commit, working tree clean\nThis shows that your local main is up to date and level with the remote main on GitHub.\n\n\n\n\n\n\nATTENTION\n\n\n\nPUBLIC REPOSITORIES ARE PUBLIC!\nThat means that anyone in the World can read everything within them, including all of your commit messages.\nNEVER push passwords or sensitive data to the repository. Make sure that you never save a password in a version controlled directory, or else you risk accidentally uploading it to the cloud.\nNEVER push private or unpublished research data. By pushing to a public repository you are making the file (and all its previous versions) public. Don’t push a file that you don’t have permission to publish. Don’t push sensitive or private research data. Don’t push grant proposals or research papers (at least, not before they have been awarded or published!).\nBE CAREFUL of offensive commit messages. It is a bad idea to be abusive or condescending in your commit messages, particularly as they will become public when you push them into a public repository. Avoid commit messages like “Fixed this annoying piece of rubbish code written by Fred”, as “Fred” is likely to see that comment once it is published.",
    "crumbs": [
      "Using GitHub"
    ]
  },
  {
    "objectID": "pages/300-directory.html",
    "href": "pages/300-directory.html",
    "title": "Creating directories",
    "section": "",
    "text": "Git is a tool that is used to version control a directory of files. To start, we must first create a directory that will contain the files that will be version controlled.\nYou can call the directory anything you want. For this workshop, we will call the directory versioned_dir. To create this, type into the command window;\nmkdir versioned_dir\nThis will have created a new directory called versioned_dir. We now need to change into this directory. Please do that by typing this into the command window;\ncd versioned_dir\n\nInitialising version control\nThe next step is to tell git that we want to start version controlling the files in this directory. We do that by initialise git using the git init command. Type this into the command window;\ngit init\nYou should see something like this printed as output to the screen;\nInitialized empty Git repository in /Users/ab01234/versioned_dir/.git/\nThis has told git to initialise a new repository in which versions of files in this directory will be saved. This repository is empty, as we have not yet saved any versions.",
    "crumbs": [
      "Creating directories"
    ]
  },
  {
    "objectID": "pages/700-changing.html",
    "href": "pages/700-changing.html",
    "title": "Restoring old versions of a file",
    "section": "",
    "text": "Restoring old versions of a file\nThe point of a version control system such as Git is that you can move between different versions of a file (or, really, of a working directory). This means that you can make changes to files while safe in the knowledge that the old versions of the file are still safe. This can save you from having to save multiple versions of a file, e.g. README.md, README_01.md, README_01_cats_meow.md etc. etc.\nTo see all of the available versions of your working directory, type the command\ngit log\nYou should see output that is similar (but definitely not identical) to this\ncommit d70cb25dae45df90a63b34314a6132d8d9a19728 (HEAD -&gt; main)\nAuthor: Jean Golding &lt;ab01234@bristol.ac.uk&gt;\nDate:   Fri Jan 15 10:08:10 2021 +0000\n\n    Added some text to something.md to see if this was found by Git\n\ncommit 26101aef6ce05d115d060bcd2b9dec97d5c2dc95\nAuthor: Jean Golding &lt;ab01234@bristol.ac.uk&gt;\nDate:   Fri Jan 15 10:07:54 2021 +0000\n\n    Added in another file\n\ncommit 3bdce3794b66af27bed3d28ee8d94aff3cc74fad\nAuthor: Jean Golding &lt;ab01234@bristol.ac.uk&gt;\nDate:   Thu Jan 14 17:46:23 2021 +0000\n\n    Fixing a typo in README.md. Cats do not go woof.\n\ncommit 1ca35e3ad694fee566ab83341938699c726a4d0d\nAuthor: Jean Golding &lt;ab01234@bristol.ac.uk&gt;\nDate:   Thu Jan 14 17:23:27 2021 +0000\n\n    Added the file README.md so that we have an initial file to\n    play with in Git\nNote that if you have a lot of commits this will open a text viewer that will let you scroll through the log. You can exit the text viewer by pressing the “q” key.\nEach commit is listed, one after another, starting from the latest commit and moving back to the first commit. Each commit represents a different version of the working directory, and is given its own unique ID, e.g. commit 3bdce3794b66af27bed3d28ee8d94aff3cc74fad is the version where I changed the file so that cats go meow.\nThe version ID is a very large number which is written in hexadecimal. This is a random large number. It is so large that it is completely unique, meaning that, in the whole World across all time, only the commit where I made cats go meow will have version number 3bdce3794b66af27bed3d28ee8d94aff3cc74fad.\nEach commit is also tagged with the name and email address of the person who committed, together with the commit message. Hopefully you can now see why this information needed to be given to git.\nBy default, git log will show information about all commits. To limit the output to only the last N commits, use the -n option. For example, to print out the log of the last 3 commits, type\ngit log -n 3\nThe log also records the date and time of each commit, and indeed, each commit represents the working directory at a different point in time. You can “move” your working directory through time by “checking out” different versions. To do this, you will need to use the unique ID of the commit you want to change to, and you will need to use the command git checkout ID. where ID is the number of the version you want to change to.\nNow, change back to the first version of your working directory. In my case, this is version 1ca35e3ad694fee566ab83341938699c726a4d0d (the ID of the last commit printed out by git log). For me, I do this by typing\ngit checkout 1ca35e3ad694fee566ab83341938699c726a4d0d\nYou will have to use the ID number of your first version.\nYou should see git output something similar to this;\nNote: switching to '1ca35e3ad694fee566ab83341938699c726a4d0d'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by switching back to a branch.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -c with the switch command. Example:\n\n  git switch -c &lt;new-branch-name&gt;\n\nOr undo this operation with:\n\n  git switch -\n\nTurn off this advice by setting config variable advice.detachedHead to false\n\nHEAD is now at 1ca35e3 Added the file README.md so that we have an initial file to play with in Git\nThis confirms that git has now changed the working directory to match version 1ca35e3ad694fee566ab83341938699c726a4d0d. It also outputs some useful information that we will come back to later…\nType ls. You should see now that there is only the file README.md in your working directory. Take a look at README.md using your text editor. You should see that this is the original version of the file, in which the cat goes woof.\nTo return back to the newest version of the working directory, type\ngit checkout main\nThis is a safe command that will always bring your working directory back so that it matches the latest version snapshot that is saved in the repository. You should get output similar to;\nPrevious HEAD position was 1ca35e3 Added the file README.md so that we have an initial file to play with in Git\nSwitched to branch 'main'\nNow, typing ls should reveal that you have both README.md and something.md. If you take a look at README.md, you should see that this is the fixed version of the file, in which the cat goes meow.\nNote that you should not edit files in an old version of the working directory. At the moment, you should treat this as a read-only view of past versions of files (you will learn how to make this an editable view in the next workshop, Git for Collaboration).\nYou can bring old versions of files into the current working directory by using git checkout VERSION FILENAME, where VERSION is the version you wish to restore, and FILENAME is the name of the file you wish to restore. For example, if I want to restore the version of README.md where cats go woof, I can type;\ngit checkout 1ca35e3ad694fee566ab83341938699c726a4d0d README.md\nTo save this change, I will need to commit, e.g.\ngit commit -a\nBut, if I wanted to revert README.md back to the latest version as saved in the repository, I should type;\ngit checkout main README.md\nThis command tells git to discard any changes made to README.md and to revert that file back to what it is like in the last committed version of the working directory in the repository. Note here that main is a special (global) git version, which refers to the latest commit of the working directory in the repository.\nIf you now run git status you should see that the working directory is clean, and a quick check of README.md in a text editor should show you that the cat is indeed going meow again.",
    "crumbs": [
      "Restoring old versions of a file"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "As part of UKRN training\n\n\n\n\n\n\n\n\nThe UK Reproducibility Network (UKRN) is a national peer-led consortium that seeks to understand the factors that contribute to poor research reproducibility and replicability, and develop collaborative approaches to counter these, in order to improve the trustworthiness and quality of research.\n\n\nGit is a version control system that allows you to save multiple versions of a file or directory. This is useful to allow you to keep a record of all changes made to a file, and to move backwards and forwards in time through different versions of it.\nThere are various implementations of version control tools. However, Git has risen to become almost the standard version control system with extremely high adoption and widespread use across academia, personal projects and industry. The State of the Octoverse gives a good idea of how widespread git has become.\nGit was originally developed to manage version control for the source code of the Linux kernel. Despite starting as a tool for programmers, it is now used to version control any kind of file, and is now widely used in academia for a whole host of projects, e.g.\n\nSaving different versions of data in a study\nSaving different versions of analysis scripts\nSaving different versions of group documents, e.g. websites, agreements, wikis or collaboration documents\n\n\nWhy is it important to use version control?\nVersion control is vital for research reproducibility as it helps track changes in data and code over time. This is particularly important in scientific projects where data and analysis evolve continuously. By using version control, researchers can:\n\nTrack Provenance: Understand what version of the data and code was used to produce specific results.\nEnsure Reproducibility: Allow others to reproduce findings by providing access to the exact versions of data and code used.\nCollaborate Effectively: Facilitate collaboration among researchers by managing changes and tracking contributions.\n\n\n\nIntended learning outcomes\nBy the end of this course, you will:\n\nUnderstand the importance of version control for research reproducibility\nCreate a directory that will contain files that can be version controlled\nSave multiple versions of files\nRetrieve old versions of files\nAdd, rename and delete version controlled files\nBack up you version controlled files to a cloud service such as GitHub\nWrite markdown to describe your version controlled files",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "pages/600-diffing.html",
    "href": "pages/600-diffing.html",
    "title": "Seeing changes (diffing)",
    "section": "",
    "text": "Git is always looking to see what has changed in your working directory. Git can tell you what has changed by using the git diff command, e.g. type\n\ngit diff\nYou should see that nothing is printed, because, at the moment, nothing has changed since the last commit.\nSo, let us now make a change. Open up the file README.md and fix the error that we made in the text. Change the line that reads\nwill say that the cat goes woof.\nto read\nwill say that the cat goes meow.\nSave and exit from the text editor, and then use the git status command to see if Git knows about this change. You should see output similar to\nOn branch main\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n    modified:   README.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nThe important line here is modified: README.md. This shows that git knows that the README.md file has been changed. To see what the change is, type the command\ngit diff\nYou should see output similar to this\ndiff --git a/README.md b/README.md\nindex 6c72b9d..1abd0a1 100644\n--- a/README.md\n+++ b/README.md\n@@ -6,5 +6,5 @@ We will use Git to record all of the versions of this file,\n letting us move back and forth through time.\n \n For example, in this first version of the file we\n-will say that the cat goes woof.\n+will say that the cat goes meow.\n\n\n\n\n\n\nDiff output\n\n\n\nNote that, if you are lucky, you should see all of the above in different colours. If you don’t see different colours, then type git config --global color.diff auto and then run git diff again.\n\n\nWhat this (overcomplicated) output shows, is that git knows that the file README.md has changed, with the line will say that the cat goes woof. being removed (indicated by the - sign), and the line will say that the cat goes meow. has been added (indicated by the + sign).\nBy default, git diff will show you all of the changes that have occurred since the last commit in all of the files in the version controlled directory (which we also call the working directory). You can limit the output to only a specific file by using git diff FILENAME, e.g. type\ngit diff README.md\nwhich should show you the changes in README.md. Now type\ngit diff something.md\nShould print no output, because something.md has not changed since the last commit.\n\nReverting a change\nMaybe you don’t want to save this change? Remember, the old version of the file is safely saved in git. We can revert back to the old version of README.md by using the command git checkout. Typing git checkout main FILENAME will revert back to the last saved version of FILENAME. Let’s revert back to our original README.md. Type;\ngit checkout main README.md\nRun git status again. You should now see that the working tree is clean, and README.md has been reverted back to the old version, where the cat goes woof.\nLet’s now change README.md again. You are free to either fix the file to make the dog goes woof or the cat goes meow (it’s your choice ;-)).\n\n\nSaving the change\nOnce you’ve fixed the file, you will need to commit the change using git commit -a and add a suitable commit message. For example, I will make the cat goes meow and will use this commit message;\nFixing a typo in README.md. Cats do not go woof.\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# On branch main\n# Changes to be committed:\n#       modified:   README.md\n#\nWhen I save and exit from the text editor I see this output from git. You should see something similar (but not identical)\n[main 3bdce37] Fixing a typo in README.md. Cats do not go woof.\n 1 file changed, 1 insertion(+), 1 deletion(-)",
    "crumbs": [
      "Seeing changes (diffing)"
    ]
  },
  {
    "objectID": "pages/990-summary.html",
    "href": "pages/990-summary.html",
    "title": "Summary",
    "section": "",
    "text": "Congratulations - you’ve now learned enough to start using git to version control your files and back them up to a secure location.\nNow that you know how git works from the command line, you are ready to start using git within a graphical interface. All of the git graphical interfaces are just running the above git commands. There are many graphical interfaces available, a lot of which are described here.\nGitHub Desktop is very good, as is the GitHub Mobile App. I also really like the integration of git into Visual Studio Code. Sublime Merge is also recommended, as is git-cola.\nIn short, choose the tool that works best for you. Have a play with them and find the one that works for you!",
    "crumbs": [
      "Summary"
    ]
  },
  {
    "objectID": "pages/500-committing.html",
    "href": "pages/500-committing.html",
    "title": "Saving a new version of a file",
    "section": "",
    "text": "Let’s take a look again at the output of git status.\nOn branch master\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached &lt;file&gt;...\" to unstage)\n    new file:   README.md\nNote here the line that says Changes to be committed. This line indicates that Git knows that something has changed in the directory, but Git hasn’t yet made a record of this change. This change is still considered to be temporary, and as such, has not yet been recorded.\nCommitting is the way to tell Git that this change should be recorded. Every time you commit a change, you record a new version of all the tracked files in your directory. When you save a version, it is like taking a snapshot of those files at this point in time.\nTo commit the change, and thus record a new snapshot view of the tracked files in this directory, type the command;\ngit commit -a\nThis will open up your text editor (e.g. nano if you set that earlier), and will place into the text editor the text\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# On branch master\n#\n# Initial commit\n#\n# Changes to be committed:\n#       new file:   README.md\n#\nThis text provides a record of everything that has changed, that is now going to be recorded. In this case, the change is that a new file has been added, called README.md. Note that there is space at the top for you to add some text, which will act as a “commit message”. This should be a human-readable description of the change, so that you can later understand why you wanted to save a new snapshot view of the directory. For example, you could type;\nAdded the file README.md so that we have an initial file to\nplay with in Git\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n# On branch master\n#\n# Initial commit\n#\n# Changes to be committed:\n#   (use \"git rm --cached &lt;file&gt;...\" to unstage)\n#\n#   new file:   README.md\n#\nSave and exit from the text editor, and you should then see output that looks similar (but not identical) to this\n[master (root-commit) 1ca35e3] Added the file README.md so that we have an initial file to play with in Git\n 1 file changed, 10 insertions(+)\n create mode 100644 README.md\nThis output is Git telling you that it has committed a change that involved one file, which contained ten new lines of text.\nNow, finally, we can use git status to see what Git now knows about this directory. You should see something like\nOn branch master\nnothing to commit, working tree clean\nCongratulations! You’ve now saved your first version of your directory to git. The phrase working tree clean means that your working tree (meaning your directory) is clean, i.e. the files in your directory exactly match the files in the last saved snapshot version in git.\nA “clean” working directory is one for which all changes have been committed, while a “dirty” working directory is one that contains changes that have not yet been committed (i.e. recorded/saved).\n\nHistorical naming\nOn newer versions of git you may see that the branch is called main instead of master. This is because the use of the word master is problematic, as the term has many negative overloaded meanings. There is a push to replace master in git with main. If you see On branch master in the git status output then you can rename master to main by typing;\ngit branch -m master main\nNow, git status should output\nOn branch main\nnothing to commit, working tree clean",
    "crumbs": [
      "Saving a new version of a file"
    ]
  },
  {
    "objectID": "pages/800-renaming.html",
    "href": "pages/800-renaming.html",
    "title": "Renaming and removing files",
    "section": "",
    "text": "So far we have only added and changed files in our version controlled working directory, and git was clever enough to work out what it needed to do. However, git does not know how to automatically work out when you have renamed or removed files.\n\nRenaming files\nTo rename a file, you have to use git mv. We are going to rename the file something.md to background.md. To do this, type\ngit mv something.md background.md\nIf you now type ls you should see that something.md has been renamed (moved) to background.md.\nNow, git status should show something like\nOn branch main\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\n    renamed:    something.md -&gt; background.md\nTo commit this change, use git commit -a as normal, remembering to add a suitable commit message, e.g.\nHave renamed something.md to background.md to better reflect\nthe contents of the file\n\n# Please enter the commit message for your changes. Lines starting\n# with '#' will be ignored, and an empty message aborts the commit.\n#\n# On branch main\n# Changes to be committed:\n#       renamed:    something.md -&gt; background.md\n#\nA quick check of git status should then show that your working directory is clean.\n\n\nRemoving files\nTo remove a file use git rm. To remove background.md we just need to type;\ngit rm background.md\nIf you now type ls you should see that background.md has been removed.\nNow git status should show something like\nOn branch main\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\n    deleted:    background.md\nNote that this has removed the file from the working directory. The file will still exist in old versions stored in the repository. We can restore this file using;\ngit checkout main background.md\nThis is the real power of using version control. It is very difficult to actually lose files or accidentally delete data. As long as you have saved a snapshot version into the repository, then you will always be able to restore the data.\nIndeed, git even tries to prevent you from losing data that is not saved to the repository. The command git rm FILE will only work if FILE is tracked by git and has no changes compared to the last version saved in the repository. To force removal of a file in this case, you need to use git rm -f FILE, where the flag -f means “force”.",
    "crumbs": [
      "Renaming and removing files"
    ]
  },
  {
    "objectID": "pages/200-cheat-sheet.html",
    "href": "pages/200-cheat-sheet.html",
    "title": "Git Cheat Sheet",
    "section": "",
    "text": "This is probably the most important page of this course, as it contains a summary of all the commands you should know to use git and github.\n\ngit init : Tell git to start version controlling the files in a directory (initialises git in a directory)\ngit status : Tell git to print the status of the files in the version controlled directory.\ngit add : Tell git to start monitoring (tracking) the versions of a new file, e.g. git add README.md will tell git to track README.md\n\ngit commit -a : Tell git to save a new snapshot version of all of the tracked files in the directory. The -a means “all files”. You can commit new versions of individual files if you want, but this is not recommended.\ngit diff : Tell git to show the differences between the files in the working directory and the last saved version in the git repository. This will show the differences for all tracked files. Use git diff FILENAME to limit to only the file FILENAME\n\ngit checkout VERSION FILENAME : Tell git to bring VERSION version of FILENAME into the current working directory. If VERSION is main then restore the last version of FILENAME that was saved to the repository. git checkout VERSION : Tell git to change the working directory back to a specific VERSION number. If VERSION is main, then return the working directory to the last saved version in the repository.\ngit log : Print a log of the versions in the repository. Use git log -n N to limit to the last N versions. You may need to use q to exit from the text viewer if there are a lot of versions to print.\ngit mv OLD NEW : Rename a file from name OLD to name NEW.\ngit rm FILENAME : Remove the file FILENAME from the working directory (it still exists in the repository). Will only work if the file is tracked by git and doesn’t have any changes. Use -f to force removal of files.\ngit clone LINK : Clone a repository from a remote repository to your local computer.\ngit push : Push versions that are saved in the local repository (.git folder) so they are backed up to a remote repository (.git folder)",
    "crumbs": [
      "Git Cheat Sheet"
    ]
  }
]